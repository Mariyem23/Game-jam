<!doctype html>
<html lang="fr">


<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kaiju ‚Äî Terrain</title>

    <style>
       :root{
  --bg:#070707;
  --ink:#e7dcc7;
  --muted:rgba(231,220,199,.75);
  --line:rgba(200,160,110,.28);
  --accent:#8c2f1f;
  --accent2:#b64a2a;

  --shadow: 0 18px 60px rgba(0,0,0,.55);
  --panelA: rgba(0,0,0,.55);
  --panelB: rgba(0,0,0,.84);

  --radius: 22px;
  --btnRadius: 12px;
}

*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}

body{
  background:
    radial-gradient(1400px 700px at 50% -10%,
      rgba(255, 190, 120, 0.45),
      transparent 55%
    ),
    radial-gradient(1200px 900px at 50% 65%,
      rgba(255, 140, 90, 0.30),
      transparent 65%
    ),
    radial-gradient(800px 600px at 50% 100%,
      rgba(255, 220, 170, 0.18),
      transparent 70%
    ),
    #0a0a0a;
}

/* ton app prend tout l‚Äô√©cran */
.app{
  height:100%;
  display:flex;
  flex-direction:column;
  padding: 18px;
  gap: 14px;
}

/* ===== HUD ===== */
.hud{
  flex:0 0 auto;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 14px;
  padding: 18px 18px 14px;
  border-radius: var(--radius);
  border: 1px solid rgba(200,160,110,.22);
  background: linear-gradient(to bottom, var(--panelA), var(--panelB));
  box-shadow: var(--shadow);
  position: relative;
  overflow:hidden;
}

.hud::before{
  content:"";
  position:absolute;
  inset:0;
  background:
    radial-gradient(600px 260px at 20% 0%, rgba(182,74,42,.12), transparent 60%),
    radial-gradient(700px 280px at 80% 30%, rgba(140,47,31,.10), transparent 65%);
  pointer-events:none;
}

.hud-left,.hud-right{
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap:wrap;
  position:relative;
  z-index:1;
}

/* tes ‚Äúpills‚Äù deviennent des mini-panneaux */
.pill{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(200,160,110,.20);
  background: rgba(0,0,0,.32);
  color: rgba(255,255,255,.86);
  backdrop-filter: blur(6px);
}

/* objectif = style titre */
.objective{
  font-family: "Cinzel", ui-serif, Georgia, serif;
  letter-spacing: 2px;
  text-transform: uppercase;
  font-size: 12px;
  color: rgba(255,255,255,.82);
  min-width: min(620px, 70vw);
}

/* √©nergie */
.gem{
  width: 12px;
  height: 12px;
  border-radius: 2px;
  background: linear-gradient(to bottom, rgba(180,90,60,.9), rgba(100,35,25,.9));
  box-shadow: 0 0 0 1px rgba(255,255,255,.08);
  transform:none;
}

.energyStack{display:flex;flex-direction:column;gap:6px;min-width:140px}
.energyNums{
  display:flex;
  align-items:baseline;
  gap:8px;
  font-family: "Cinzel", ui-serif, Georgia, serif;
  letter-spacing: 2px;
  font-size: 11px;
}
.energyNums b{
  font-size: 14px;
  color: rgba(255,255,255,.92);
}

.energyBar{
  width: 160px;
  height: 10px;
  border-radius: 999px;
  border: 1px solid rgba(200,160,110,.20);
  background: rgba(0,0,0,.35);
  overflow:hidden;
}
.energyFill{
  height:100%;
  width:0%;
  background: linear-gradient(to right, rgba(182,74,42,.25), rgba(182,74,42,.95));
  transition: width 180ms ease;
}

/* ===== BOUTONS ===== */
.btn{
  cursor:pointer;
  height: 42px;
  padding: 0 14px;
  border-radius: var(--btnRadius);
  font-family: "Cinzel", ui-serif, Georgia, serif;
  letter-spacing: 2px;
  text-transform: uppercase;
  background: #5c291f;
  color: #f1e6cf;
  border: 1px solid rgba(138,111,76,.60);
  box-shadow: 0 14px 40px rgba(0,0,0,.45);
}

.btn:hover{filter:brightness(1.06); transform: translateY(-1px)}
.btn:active{transform: translateY(0); filter:brightness(.98)}

/* ===== STAGE / CANVAS ===== */
.stage{
  flex:1 1 auto;
  min-height:0;
  border-radius: var(--radius);
  border: 1px solid rgba(220,180,120,.28);
  background: rgba(10,10,10,.55);
  box-shadow:
    0 18px 60px rgba(0,0,0,.55),
    inset 0 0 120px rgba(180,90,60,.08);
  overflow:hidden;
  position:relative;
}

.stage::before{
  content:"";
  position:absolute;
  inset:0;
  background:
    radial-gradient(900px 420px at 50% 30%,
      rgba(200,100,70,.25),
      transparent 55%
    ),
    radial-gradient(900px 700px at 50% 90%,
      rgba(0,0,0,0),
      rgba(0,0,0,.35)
    );
  pointer-events:none;
}

canvas{
  width:100%;
  height:100%;
  display:block;

  /* ‚úÖ boost luminosit√©/contraste sans toucher au JS */
  filter: brightness(1.25) contrast(1.12) saturate(1.18);
}
/* responsive */
@media (max-width:720px){
  body{overflow:hidden}
  .app{padding:12px; gap:12px}
  .objective{min-width:0}
  .energyBar{width:140px}
}
    </style>
</head>

<body>
    <!-- Musique de fond -->
    <audio id="bg-music" src="../../assets/fond.mp3" autoplay loop></audio>
    
    <!-- Son Kaiju apparition -->
    <audio id="sfx-kaiju-in" src="son/apparition.mp3" preload="auto"></audio>
    <!-- Son Kaiju disparition -->
    <audio id="sfx-kaiju-out" src="son/disparaitre.mp3" preload="auto"></audio>
    </audio>
    <div class="app">

        <!-- UI TOP -->
        <div class="hud">
            <div class="hud-left">
                <div class="pill objective">
                    Objectif : r√©cup√©rer les 15 modules d‚Äô√©nergie.
                </div>
            </div>

            <div class="hud-right">
                <div class="pill energy" id="energyPill">
                    <span class="gem" aria-hidden="true"></span>

                    <div class="energyStack">
                        <div class="energyNums"><b id="energy">0</b><span style="opacity:.65;"></span></div>

                        <div class="energyBar" aria-hidden="true">
                            <div class="energyFill" id="energyFill"></div>
                        </div>
                    </div>
                </div>
                <button class="btn" id="toggleEdit">Mode √©dition: OFF</button>
                <button class="btn" id="reset">Reset positions</button>
            </div>
        </div>

        <!-- GAME FULL -->
        <div class="stage">
            <canvas id="game" width="1280" height="720"></canvas>
        </div>

    </div>



    <script>
        (() => {
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");
            const kaijuImg = new Image();
            kaijuImg.src = "image/tete_de_kaijo.png";
            // ===== EXPLOSION (quand tu meurs) =====
            const DEATHFX = {
                on: false,
                x: 0,
                y: 0,
                t: 0,
                dur: 0.9,     // dur√©e explosion
            };

            let screenShake = 0; // intensit√© tremblement
            let loseTextDelay = 0; // temps avant d'afficher "T'AS PERDU"
            function resizeCanvasToDisplaySize() {
                const r = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                const w = Math.round(r.width * dpr);
                const h = Math.round(r.height * dpr);

                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                }
            }

            window.addEventListener("resize", resizeCanvasToDisplaySize);

            const uiHovered = document.getElementById("hovered");   // peut √™tre null
            const uiSelected = document.getElementById("selected"); // peut √™tre null
            const btnToggleEdit = document.getElementById("toggleEdit");
            const btnReset = document.getElementById("reset");
            
            // ===== SFX KAIJU =====
            const sfxKaijuIn = document.getElementById("sfx-kaiju-in");
            const sfxKaijuOut = document.getElementById("sfx-kaiju-out");

            function playSfx(aud, volume = 0.9) {
                if (!aud) return;
                aud.pause();
                aud.currentTime = 0;
                aud.volume = volume;
                aud.play().catch(() => { });
            }

            let gameOver = false;
            let gameWon = false;
            let gameOverMsg = "";

            const energyUI = document.getElementById("energy");
            // ===== VICTORY FX =====
            const WINFX = {
                on: false,
                x: 0,
                y: 0,
                t: 0,
                dur: 1.4,
            };

            let winTextDelay = 0; // d√©lai avant "TU AS GAGN√â"
            function updateEnergyUI() {
                energyUI.textContent = `${ENERGY.collected}/${ENERGY.goal}`;
                const p = Math.max(0, Math.min(1, ENERGY.collected / ENERGY.goal));
                if (energyFill) energyFill.style.width = `${p * 100}%`;
            }

            const ENERGY = {
                collected: 0,
                goal: 15,
                nodeId: null,   // case o√π se trouve le module
            };

            let nextFireIn = 2.0; // premi√®re attaque apr√®s 2 sec

            let bombTimer = 10.0;     // premi√®re bombe apr√®s 10s
            const BOMB_INTERVAL = 3.0; // ensuite toutes les 3s
            // ====== TERRAIN ======
            const initialNodes = [
                { id: 0, x: 220, y: 520 },
                { id: 1, x: 320, y: 250 },
                { id: 2, x: 430, y: 390 },
                { id: 3, x: 520, y: 160 },
                { id: 4, x: 590, y: 600 },
                { id: 5, x: 650, y: 330 },
                { id: 6, x: 760, y: 250 },
                { id: 7, x: 880, y: 160 },
                { id: 8, x: 980, y: 280 },
                { id: 9, x: 910, y: 420 },
                { id: 10, x: 1120, y: 520 },
            ];

            const edges = [
                [0, 1], [0, 2], [0, 4],
                [1, 2], [1, 3],
                [2, 3], [2, 5],
                [5, 6], [5, 9],
                [6, 7],
                [7, 8],
                [8, 9], [8, 10],
                [9, 10],
                [4, 10],
            ];

            let nodes = initialNodes.map(n => ({ ...n }));
            function getNodesBounds() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const n of nodes) {
                    minX = Math.min(minX, n.x); minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x); maxY = Math.max(maxY, n.y);
                }
                return { minX, minY, maxX, maxY };
            }

            function getCenterOffset() {
                const b = getNodesBounds();
                const cx = (b.minX + b.maxX) / 2;
                const cy = (b.minY + b.maxY) / 2;
                return { ox: canvas.width / 2 - cx, oy: canvas.height / 2 - cy };
            }

            // ====== ADJ (voisins) ======
            const adj = new Map();
            for (const n of initialNodes) adj.set(n.id, []);
            for (const [a, b] of edges) {
                adj.get(a).push(b);
                adj.get(b).push(a);
            }

            // ====== UI / Interaction ======
            let hoveredId = null;
            let selectedId = null;

            let editMode = false;
            let draggingId = null;
            let dragOffset = { x: 0, y: 0 };

            const NODE_RADIUS = 28;
            const EDGE_WIDTH = 10;

            function setEditMode(on) {
                editMode = on;
                btnToggleEdit.textContent = `Mode √©dition: ${editMode ? "ON" : "OFF"}`;
            }

            function resetPositions() {
                nodes = initialNodes.map(n => ({ ...n }));
                initPlayer();
                initKaijuSpawnSystem();
                ENERGY.collected = 0;
                energyUI.textContent = "0";
                spawnEnergyModule();
            }

            // ====== Helpers ======
            function dist2(ax, ay, bx, by) {
                const dx = ax - bx, dy = ay - by;
                return dx * dx + dy * dy;
            }

            function getMousePos(evt) {
                const r = canvas.getBoundingClientRect();
                const scaleX = canvas.width / r.width;
                const scaleY = canvas.height / r.height;

                const { ox, oy } = getCenterOffset(); // important: centrage

                return {
                    x: (evt.clientX - r.left) * scaleX - ox,
                    y: (evt.clientY - r.top) * scaleY - oy
                };
            }

            function hitNode(mx, my) {
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const n = nodes[i];
                    if (dist2(mx, my, n.x, n.y) <= NODE_RADIUS * NODE_RADIUS) return n.id;
                }
                return null;
            }

            function getNode(id) { return nodes.find(n => n.id === id); }


            //Fonction pour faire appara√Ætre un module sur une case al√©atoire
            function randomInt(max) { return Math.floor(Math.random() * max); }

            function spawnEnergyModule() {
                let newId;

                do {
                    newId = nodes[Math.floor(Math.random() * nodes.length)].id;
                } while (
                    newId === ENERGY.nodeId ||   // pas la m√™me case
                    newId === playerNodeId       // pas sous le joueur
                );

                ENERGY.nodeId = newId;
            }

            function collectEnergyIfOnNode() {
                if (ENERGY.nodeId === null || gameWon || gameOver) return;

                if (playerNodeId === ENERGY.nodeId) {
                    ENERGY.collected++;

                    const n = getNode(ENERGY.nodeId);
                    if (n) spawnEnergyPop(n.x, n.y);

                    updateEnergyUI();

                    if (ENERGY.collected >= ENERGY.goal) {
                        gameWon = true;

                        // FX victoire au centre du joueur
                        WINFX.on = true;
                        WINFX.t = 0;
                        WINFX.x = playerPos.x;
                        WINFX.y = playerPos.y;

                        winTextDelay = 0.65;
                        screenShake = 10;

                        endMsg = `Bravo Tu as collect√© ${ENERGY.collected} modules d'√©nergie !`;
                    } else {
                        // ‚úÖ IMPORTANT : d√©placer le module ailleurs
                        spawnEnergyModule();
                    }
                }
            }

            // ====== JOUEUR ======
            let playerNodeId = 1;
            let playerPos = { x: 0, y: 0 };
            let playerTarget = { x: 0, y: 0 };
            let isMoving = false;
            let playerTrail = []; // tra√Æn√©e (positions)
            const TRAIL_MAX = 14;

            const PLAYER_SPEED = 520; // px/s

            function initPlayer() {
                const start = getNode(playerNodeId);
                playerPos.x = start.x; playerPos.y = start.y;
                playerTarget.x = start.x; playerTarget.y = start.y;
                isMoving = false;
            }

            function canMoveTo(fromId, toId) {
                return adj.get(fromId)?.includes(toId);
            }

            function movePlayerTo(nodeId) {
                if (isMoving) return;
                if (!canMoveTo(playerNodeId, nodeId)) return;

                const dest = getNode(nodeId);
                if (!dest) return;

                isMoving = true;
                playerNodeId = nodeId;
                playerTarget.x = dest.x;
                playerTarget.y = dest.y;
            }

            // ====== KAIJU (spawn sur case 10, chase 7s, respawn timer) ======********************************************************************
            const KAIJU = {
                state: "idle",      // "idle" | "warning" | "active"
                nodeId: 10,
                pos: { x: 0, y: 0 },
                target: { x: 0, y: 0 },
                moving: false,

                // timers
                spawnIn: 25.0,      // 1√®re apparition apr√®s 30s
                nextInterval: 10.0, // ensuite toutes les 15s
                activeLeft: 0,      // temps restant en chase

                // warning blink
                wT: 0,
                wStep: 0,           // 0 ON, 1 OFF, 2 ON
                wVisible: true,
            };
            let kaijuTrail = [];
            const KTRAIL_MAX = 18; // + grand = plus long
            const KAIJU_WARN_ON = 0.5;
            const KAIJU_WARN_OFF = 0.5;
            const KAIJU_ACTIVE_DURATION = 8.0;         // chase 8s
            const KAIJU_SPEED = PLAYER_SPEED * 0.7;   // presque pareil que joueur 
            let kaijuStepTimer = 0.0;                  // tempo d√©cision de pas

            function initKaijuSpawnSystem() {
                KAIJU.state = "idle";
                KAIJU.spawnIn = 25.0;
                KAIJU.activeLeft = 0;
                KAIJU.moving = false;

                const start = getNode(10);
                KAIJU.pos.x = start.x; KAIJU.pos.y = start.y;
                KAIJU.target.x = start.x; KAIJU.target.y = start.y;
            }

            // plus court chemin: renvoie le "prochain pas" vers goal
            function bfsNextStep(startId, goalId) {
                if (startId === goalId) return startId;

                const q = [startId];
                const prev = new Map();
                prev.set(startId, null);

                while (q.length) {
                    const cur = q.shift();
                    for (const nb of (adj.get(cur) || [])) {
                        if (prev.has(nb)) continue;
                        prev.set(nb, cur);

                        if (nb === goalId) {
                            // remonter jusqu'au premier pas
                            let step = nb;
                            let p = prev.get(step);
                            while (p !== startId && p !== null) {
                                step = p;
                                p = prev.get(step);
                            }
                            return step;
                        }
                        q.push(nb);
                    }
                }
                return startId;
            }

            function startKaijuWarning() {
                // place kaiju sur node 10 (sans √™tre visible "active" encore)
                KAIJU.nodeId = 10;
                const n = getNode(10);
                KAIJU.pos.x = n.x; KAIJU.pos.y = n.y;
                KAIJU.target.x = n.x; KAIJU.target.y = n.y;
                KAIJU.moving = false;

                KAIJU.state = "warning";
                KAIJU.wT = 0;
                KAIJU.wStep = 0;
                KAIJU.wVisible = true;
                playSfx(sfxKaijuIn, 0.85);
            }

            function startKaijuActive() {
                KAIJU.state = "active";
                KAIJU.activeLeft = KAIJU_ACTIVE_DURATION;
                kaijuStepTimer = 0.0;
            }

            function hideKaiju() {
                KAIJU.state = "idle";
                KAIJU.moving = false;
                KAIJU.activeLeft = 0;
                // üîä SON DISPARITION KAIJU
                playSfx(sfxKaijuOut, 0.75);
            }

            function updateKaiju(dt) {
                if (gameOver || gameWon) return;

                // timer spawn global
                if (KAIJU.state === "idle") {
                    KAIJU.spawnIn -= dt;
                    if (KAIJU.spawnIn <= 0) {
                        startKaijuWarning();
                        // pr√©pare le prochain spawn (dans 20s) ‚Äî on le remettra apr√®s fin de chase
                        KAIJU.spawnIn = KAIJU.nextInterval;
                    }
                    return;
                }

                // warning blink 2 fois
                if (KAIJU.state === "warning") {
                    KAIJU.wT += dt;

                    if (KAIJU.wStep === 0) {
                        KAIJU.wVisible = true;
                        if (KAIJU.wT >= KAIJU_WARN_ON) { KAIJU.wT = 0; KAIJU.wStep = 1; }
                    } else if (KAIJU.wStep === 1) {
                        KAIJU.wVisible = false;
                        if (KAIJU.wT >= KAIJU_WARN_OFF) { KAIJU.wT = 0; KAIJU.wStep = 2; }
                    } else {
                        KAIJU.wVisible = true;
                        if (KAIJU.wT >= KAIJU_WARN_ON) {
                            startKaijuActive();
                        }
                    }
                    return;
                }

                // active chase
                if (KAIJU.state === "active") {
                    KAIJU.activeLeft -= dt;
                    if (KAIJU.activeLeft <= 0) {
                        hideKaiju();
                        return;
                    }

                    // d√©cide un pas toutes les ~0.8s (ajuste)
                    kaijuStepTimer -= dt;
                    if (kaijuStepTimer <= 0 && !KAIJU.moving) {
                        const next = bfsNextStep(KAIJU.nodeId, playerNodeId);
                        if (next !== KAIJU.nodeId) {
                            const dest = getNode(next);
                            KAIJU.nodeId = next;
                            KAIJU.target.x = dest.x;
                            KAIJU.target.y = dest.y;
                            KAIJU.moving = true;
                        }
                        kaijuStepTimer = 0.6 + Math.random() * 0.4; // 0.6‚Äì1.0s
                    }

                    // animation d√©placement kaiju
                    if (KAIJU.moving) {
                        // Trail (chaleur) pendant le mouvement
                        kaijuTrail.push({ x: KAIJU.pos.x, y: KAIJU.pos.y, life: 1 });
                        if (kaijuTrail.length > KTRAIL_MAX) kaijuTrail.shift();
                        const dx = KAIJU.target.x - KAIJU.pos.x;
                        const dy = KAIJU.target.y - KAIJU.pos.y;
                        const dist = Math.hypot(dx, dy);
                        const step = KAIJU_SPEED * dt;

                        if (dist <= step) {
                            KAIJU.pos.x = KAIJU.target.x;
                            KAIJU.pos.y = KAIJU.target.y;
                            KAIJU.moving = false;

                            // si kaiju arrive sur la case du joueur -> perdu
                            if (KAIJU.nodeId === playerNodeId) {
                                killPlayer("Le Kaiju t'a rattrap√© !");
                            }
                        } else {
                            KAIJU.pos.x += (dx / dist) * step;
                            KAIJU.pos.y += (dy / dist) * step;
                        }
                        // Fade de la trail (plus lente = plus visible)
                        for (const p of kaijuTrail) p.life -= dt * 1.1;
                        kaijuTrail = kaijuTrail.filter(p => p.life > 0);
                    }
                }
            }

            function drawKaiju() {
                if (KAIJU.state === "idle") return;

                const x = KAIJU.pos.x;
                const y = KAIJU.pos.y;

                ctx.save();

                // ===== TRAIL BLEUE (forte + contrast√©e) =====
                if (kaijuTrail.length >= 2) {
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";

                    for (let i = 0; i < kaijuTrail.length - 1; i++) {
                        const a = kaijuTrail[i];
                        const b = kaijuTrail[i + 1];
                        const t = a.life; // 1 -> 0

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const ang = Math.atan2(dy, dx);
                        const dist = Math.hypot(dx, dy);

                        ctx.save();
                        ctx.translate(a.x, a.y);
                        ctx.rotate(ang);

                        const w = Math.max(30, dist * 1.2);
                        const h = 34;

                        // couche externe (bleu intense)
                        ctx.fillStyle = `rgba(0, 170, 255, ${0.55 * t})`;
                        roundRectFill(-w * 0.25, -h / 2, w, h, 999);

                        // coeur (presque blanc)
                        ctx.fillStyle = `rgba(220, 250, 255, ${0.22 * t})`;
                        roundRectFill(-w * 0.12, -h * 0.32, w * 0.78, h * 0.64, 999);

                        ctx.restore();
                    }

                    ctx.globalCompositeOperation = "source-over";
                    ctx.restore();
                }

                // ===== HALO BLEU AUTOUR (plus fort si bouge) =====
                const heat = KAIJU.moving ? 1.2 : 0.7;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                ctx.fillStyle = `rgba(0, 170, 255, ${0.22 * heat})`;
                ctx.beginPath();
                ctx.arc(x, y, 60 * heat, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(0, 120, 255, ${0.16 * heat})`;
                ctx.beginPath();
                ctx.arc(x, y, 42 * heat, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();

                // ===== IMAGE KAIJU =====
                const size = 120;
                ctx.drawImage(kaijuImg, x - size / 2, y - size / 2, size, size);

                ctx.restore();
            }

            // ====== ATTAQUE FEU (bordure -> ligne -> projectile) ======*******************************************************************************

            const FIRE = {
                state: "idle",    // "idle" | "warning" | "firing"
                axis: "h",        // "h" ou "v"
                lineX: 0,
                lineY: 0,
                t: 0,
                blinkStep: 0,     // 0 ON, 1 OFF, 2 ON
                visible: true,
                projectile: null, // {x,y,vx,vy}
            };

            const WARN_ON = 0.5;
            const WARN_OFF = 0.5;
            const FIRE_SPEED = PLAYER_SPEED * 1.6;  // ~ vitesse joueur
            const FIRE_RADIUS = 40;           // üî• plus gros (augmente si tu veux)
            const PLAYER_RADIUS = 18;
            const WARNING_SCALE = 2.4;              // ‚ö†Ô∏è ic√¥ne plus grande
            function startFireAttack(axis) {


                FIRE.axis = axis;

                // Important: on "verrouille" la ligne au moment du warning (sinon √ßa bouge trop)
                FIRE.lineX = playerPos.x;
                FIRE.lineY = playerPos.y;

                FIRE.state = "warning";
                FIRE.t = 0;
                FIRE.blinkStep = 0;
                FIRE.visible = true;
                FIRE.projectile = null;
            }
            // ===== LIMITES DU TERRAIN (zone bleue) =====
            function getPlayBounds() {
                // limites bas√©es sur ton graphe (terrain), pas sur l'√©cran
                const b = getNodesBounds();
                const pad = 80; // marge autour du graphe (augmente/diminue)

                return {
                    left: b.minX - pad,
                    right: b.maxX + pad,
                    top: b.minY - pad,
                    bottom: b.maxY + pad
                };
            }

            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }

            function spawnProjectile() {
                const b = getPlayBounds();

                FIRE.lineX = clamp(FIRE.lineX, b.left, b.right);
                FIRE.lineY = clamp(FIRE.lineY, b.top, b.bottom);

                const off = 220; // distance hors terrain avant d'entrer

                if (FIRE.axis === "h") {
                    const fromLeft = Math.random() < 0.5;
                    FIRE.projectile = {
                        x: fromLeft ? b.left - off : b.right + off,
                        y: FIRE.lineY,
                        vx: fromLeft ? FIRE_SPEED : -FIRE_SPEED,
                        vy: 0
                    };
                } else {
                    const fromTop = Math.random() < 0.5;
                    FIRE.projectile = {
                        x: FIRE.lineX,
                        y: fromTop ? b.top - off : b.bottom + off,
                        vx: 0,
                        vy: fromTop ? FIRE_SPEED : -FIRE_SPEED
                    };
                }
            }

            function killPlayer(reason) {
                loseTextDelay = 0.81; // 0.55s avant le texte
                gameOver = true;
                gameOverMsg = "T'as perdu ‚Äî " + reason;

                // üî• d√©clenche explosion √† la position du joueur
                DEATHFX.on = true;
                DEATHFX.t = 0;
                DEATHFX.x = playerPos.x;
                DEATHFX.y = playerPos.y;

                screenShake = 18; // tremblement fort

                // stop feu
                FIRE.state = "idle";
                FIRE.projectile = null;

                // stop mouvement
                isMoving = false;
            }

            function updateFire(dt) {

                if (FIRE.state === "idle") return;

                if (FIRE.state === "warning") {
                    FIRE.t += dt;

                    if (FIRE.blinkStep === 0) {
                        FIRE.visible = true;
                        if (FIRE.t >= WARN_ON) { FIRE.t = 0; FIRE.blinkStep = 1; }
                    } else if (FIRE.blinkStep === 1) {
                        FIRE.visible = false;
                        if (FIRE.t >= WARN_OFF) { FIRE.t = 0; FIRE.blinkStep = 2; }
                    } else {
                        FIRE.visible = true;
                        if (FIRE.t >= WARN_ON) {
                            FIRE.state = "firing";
                            spawnProjectile();
                        }
                    }
                    return;
                }

                // firing
                const p = FIRE.projectile;
                if (!p) { FIRE.state = "idle"; return; }

                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // collision joueur vs boule de feu
                const d = Math.hypot(playerPos.x - p.x, playerPos.y - p.y);
                if (d <= (PLAYER_RADIUS + FIRE_RADIUS)) {
                    killPlayer("Touch√© par le feu !");
                }

                // fin quand sort de l'√©cran
                const b = getPlayBounds();
                const out = 260;
                if (p.x < b.left - out || p.x > b.right + out || p.y < b.top - out || p.y > b.bottom + out) {
                    FIRE.state = "idle";
                    FIRE.projectile = null;
                }
            }


            function drawWarningAt(x, y) {
                ctx.save();
                ctx.translate(x, y);

                const s = WARNING_SCALE;

                ctx.fillStyle = "#ffd400";
                ctx.beginPath();
                ctx.moveTo(0, -22 * s);
                ctx.lineTo(22 * s, 18 * s);
                ctx.lineTo(-22 * s, 18 * s);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = "#111";
                ctx.font = `bold ${Math.round(22 * s)}px system-ui`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("!", 0, 4 * s);

                ctx.restore();
            }
            function drawBorderWarning() {
                if (FIRE.state !== "warning" || !FIRE.visible) return;

                const b = getPlayBounds();

                ctx.save();
                ctx.strokeStyle = "rgba(255,0,0,0.35)";
                ctx.lineWidth = 8;
                ctx.lineCap = "round";

                if (FIRE.axis === "h") {
                    const y = FIRE.lineY;
                    ctx.beginPath();
                    ctx.moveTo(b.left, y);
                    ctx.lineTo(b.right, y);
                    ctx.stroke();

                    drawWarningAt(b.left, y);
                    drawWarningAt(b.right, y);
                } else {
                    const x = FIRE.lineX;
                    ctx.beginPath();
                    ctx.moveTo(x, b.top);
                    ctx.lineTo(x, b.bottom);
                    ctx.stroke();

                    drawWarningAt(x, b.top);
                    drawWarningAt(x, b.bottom);
                }

                ctx.restore();
            }
            function drawFireballAura(x, y, vx, vy, baseR) {
                const speed = Math.hypot(vx, vy);
                if (speed < 0.01) return;

                const nx = vx / speed;
                const ny = vy / speed;

                const stretch = Math.min(70, speed * 0.22); // longueur aura
                const t = performance.now() * 0.006;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // ===== AURA PRINCIPALE (directionnelle)
                {
                    const g = ctx.createRadialGradient(
                        x - nx * stretch * 0.6,
                        y - ny * stretch * 0.6,
                        baseR * 0.4,
                        x - nx * stretch,
                        y - ny * stretch,
                        baseR + stretch
                    );

                    g.addColorStop(0.0, "rgba(180,245,255,0.45)");
                    g.addColorStop(0.4, "rgba(120,220,255,0.30)");
                    g.addColorStop(1.0, "rgba(0,160,255,0.00)");

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.ellipse(
                        x - nx * stretch * 0.6,
                        y - ny * stretch * 0.6,
                        baseR + stretch * 0.9,
                        baseR * 0.85,
                        Math.atan2(ny, nx),
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                // ===== PULSE CHALEUR
                {
                    const pulse = Math.sin(t * 2.2) * 0.5 + 0.5;
                    const r = baseR + 10 + pulse * 6;

                    ctx.strokeStyle = `rgba(140,230,255,${0.18 + pulse * 0.18})`;
                    ctx.lineWidth = 10 + pulse * 8;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();
            }
            function drawFireball() {
                if (FIRE.state !== "firing" || !FIRE.projectile) return;

                const p = FIRE.projectile;
                const x = p.x, y = p.y;
                drawFireballAura(x, y, p.vx, p.vy, FIRE_RADIUS + 8);

                // Taille visuelle (tu peux ajuster)
                const R = FIRE_RADIUS;          // rayon "hitbox"
                const outer = R + 26;           // halo externe
                const inner = R + 6;            // bord lumineux

                const t = performance.now() * 0.006; // animation

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // ===== HALO EXTERNE (bleu)
                {
                    const g = ctx.createRadialGradient(x, y, 0, x, y, outer);
                    g.addColorStop(0.00, "rgba(220,255,255,0.55)");
                    g.addColorStop(0.35, "rgba(120,235,255,0.35)");
                    g.addColorStop(1.00, "rgba(0,180,255,0.00)");
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, outer, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ===== BORD DENTEL√â (comme ton image)
                {
                    const spikes = 64;        // + = bord plus "cr√©nel√©"
                    const amp = 5.5;          // amplitude des dents
                    ctx.fillStyle = "rgba(120,235,255,0.55)";

                    ctx.beginPath();
                    for (let i = 0; i <= spikes; i++) {
                        const a = (i / spikes) * Math.PI * 2;
                        const wobble = Math.sin(a * 18 + t) * amp + Math.sin(a * 7 - t * 1.2) * (amp * 0.45);
                        const rr = inner + wobble;
                        const px = x + Math.cos(a) * rr;
                        const py = y + Math.sin(a) * rr;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // ===== DISQUE PRINCIPAL (bleu clair)
                {
                    const g2 = ctx.createRadialGradient(x, y, 0, x, y, R + 10);
                    g2.addColorStop(0.00, "rgba(235,255,255,0.98)");
                    g2.addColorStop(0.55, "rgba(170,245,255,0.92)");
                    g2.addColorStop(1.00, "rgba(80,220,255,0.85)");
                    ctx.fillStyle = g2;
                    ctx.beginPath();
                    ctx.arc(x, y, R + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ===== CENTRE plus doux
                {
                    ctx.fillStyle = "rgba(255,255,255,0.25)";
                    ctx.beginPath();
                    ctx.arc(x, y, R * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();
            }

            // ====== ATTAQUE BOMBE (zone rouge -> explosion) ======***********************************************************************************
            const BOMB = {
                state: "idle",     // "idle" | "warning" | "exploding"
                x: 0,
                y: 0,
                r: 260,            // rayon du cercle rouge (augmente/r√©duit)
                t: 0,
                blinkStep: 0,      // 0 ON, 1 OFF, 2 ON
                visible: true,
                affected: [],      // ids des cases touch√©es
                explosionT: 0,     // timer explosion
            };

            const BOMB_WARN_ON = 0.5;
            const BOMB_WARN_OFF = 0.5;
            const EXPLOSION_DURATION = 0.6; // dur√©e animation explosion

            function pickRandomBombCenter() {
                const n = nodes[Math.floor(Math.random() * nodes.length)];
                return { x: n.x, y: n.y };
            }

            function computeAffectedNodes(cx, cy, radius) {
                const out = [];
                const r2 = radius * radius;
                for (const n of nodes) {
                    const dx = n.x - cx;
                    const dy = n.y - cy;
                    if (dx * dx + dy * dy <= r2) out.push(n.id);
                }
                return out;
            }

            function startBombAttack() {
                if (gameOver || gameWon) return;
                if (BOMB.state !== "idle") return;       // une bombe √† la fois


                const c = pickRandomBombCenter();
                BOMB.x = c.x;
                BOMB.y = c.y;
                BOMB.affected = computeAffectedNodes(BOMB.x, BOMB.y, BOMB.r);

                BOMB.state = "warning";
                BOMB.t = 0;
                BOMB.blinkStep = 0;
                BOMB.visible = true;
                BOMB.explosionT = 0;
            }

            function updateBomb(dt) {
                if (BOMB.state === "idle") return;

                if (BOMB.state === "warning") {
                    BOMB.t += dt;

                    if (BOMB.blinkStep === 0) {
                        BOMB.visible = true;
                        if (BOMB.t >= BOMB_WARN_ON) { BOMB.t = 0; BOMB.blinkStep = 1; }
                    } else if (BOMB.blinkStep === 1) {
                        BOMB.visible = false;
                        if (BOMB.t >= BOMB_WARN_OFF) { BOMB.t = 0; BOMB.blinkStep = 2; }
                    } else {
                        BOMB.visible = true;
                        if (BOMB.t >= BOMB_WARN_ON) {
                            // BOOM
                            BOMB.state = "exploding";
                            BOMB.explosionT = 0;

                            // si joueur sur une case touch√©e -> perdu
                            if (BOMB.affected.includes(playerNodeId)) {
                                killPlayer("Touch√© par la bombe !");
                            }
                        }
                    }
                    return;
                }

                // explosion anim
                if (BOMB.state === "exploding") {
                    BOMB.explosionT += dt;
                    if (BOMB.explosionT >= EXPLOSION_DURATION) {
                        BOMB.state = "idle";
                    }
                }
            }

            function drawBombWarning() {
                if (BOMB.state !== "warning" || !BOMB.visible) return;

                // cercle rouge translucide
                ctx.save();
                ctx.fillStyle = "rgba(255, 0, 0, 0.18)";
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, BOMB.r, 0, Math.PI * 2);
                ctx.fill();

                // contour
                ctx.strokeStyle = "rgba(255, 0, 0, 0.45)";
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, BOMB.r, 0, Math.PI * 2);
                ctx.stroke();

                // ic√¥ne ! au centre (r√©utilise ton style)
                drawWarningAt(BOMB.x, BOMB.y);

                ctx.restore();
            }

            function drawBombExplosion() {
                if (BOMB.state !== "exploding") return;

                const t = Math.min(1, BOMB.explosionT / EXPLOSION_DURATION);

                // expansion + fade
                const R = BOMB.r * (0.6 + 0.6 * t);

                ctx.save();

                // flash central
                ctx.fillStyle = `rgba(255,120,0,${0.25 * (1 - t)})`;
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, R, 0, Math.PI * 2);
                ctx.fill();

                // ring
                ctx.strokeStyle = `rgba(255,60,0,${0.55 * (1 - t)})`;
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, R, 0, Math.PI * 2);
                ctx.stroke();

                // marque les cases touch√©es en rouge pendant l'explosion
                for (const id of BOMB.affected) {
                    const n = getNode(id);
                    if (!n) continue;
                    ctx.fillStyle = `rgba(255,0,0,${0.22 * (1 - t)})`;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 14, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // ====== Animation update ======
            let lastTime = performance.now();
            function update() {
                const now = performance.now();
                const dt = Math.min(0.033, (now - lastTime) / 1000);
                lastTime = now;


                // ===== BOMBE AUTO =====
                bombTimer -= dt;
                if (bombTimer <= 0) {
                    startBombAttack();
                    bombTimer = BOMB_INTERVAL;
                }

                // Timer attaque auto
                nextFireIn -= dt;
                if (nextFireIn <= 0) {
                    startRandomFireAttack();
                    // Prochaine attaque al√©atoire entre 1.8s et 3.5s
                    nextFireIn = 1.8 + Math.random() * 1.7;
                }

                // player move
                if (isMoving) {
                    playerTrail.push({ x: playerPos.x, y: playerPos.y, life: 1 });
                    if (playerTrail.length > TRAIL_MAX) playerTrail.shift();
                    const dx = playerTarget.x - playerPos.x;
                    const dy = playerTarget.y - playerPos.y;
                    const dist = Math.hypot(dx, dy);
                    const step = PLAYER_SPEED * dt;

                    if (dist <= step) {
                        playerPos.x = playerTarget.x;
                        playerPos.y = playerTarget.y;
                        isMoving = false;

                        collectEnergyIfOnNode(); //l'energi collecter
                    } else {
                        playerPos.x += (dx / dist) * step;
                        playerPos.y += (dy / dist) * step;
                    }
                }
                for (const p of playerTrail) p.life -= dt * 2.2;  // vitesse de disparition
                playerTrail = playerTrail.filter(p => p.life > 0);

                // fire attack
                updateFire(dt);
                updateBomb(dt);
                updateKaiju(dt);
                updateEnergyFX(dt);
                // update explosion mort
                if (DEATHFX.on) {
                    DEATHFX.t += dt;
                    if (DEATHFX.t >= DEATHFX.dur) DEATHFX.on = false;
                }

                // amortit le tremblement
                screenShake *= Math.pow(0.001, dt); // decay smooth


                // ‚úÖ Les d√©lais doivent diminuer
                if (winTextDelay > 0) winTextDelay -= dt;
                if (loseTextDelay > 0) loseTextDelay -= dt;

                // ‚úÖ timer victoire (sinon drawVictoryFX reste fig√©)
                if (WINFX.on) {
                    WINFX.t += dt;
                    if (WINFX.t >= WINFX.dur) WINFX.on = false;
                }

                // ‚úÖ STOP gameplay si fin de jeu (mais laisse les FX)
                if (gameOver || gameWon) {
                    // timers / FX continuent
                    if (winTextDelay > 0) winTextDelay -= dt;
                    if (loseTextDelay > 0) loseTextDelay -= dt;

                    if (WINFX.on) {
                        WINFX.t += dt;
                        if (WINFX.t >= WINFX.dur) WINFX.on = false;
                    }

                    if (DEATHFX.on) {
                        DEATHFX.t += dt;
                        if (DEATHFX.t >= DEATHFX.dur) DEATHFX.on = false;
                    }

                    screenShake *= Math.pow(0.001, dt);
                    updateEnergyFX(dt);

                    return; // ‚õî emp√™che bomb/fire/kaiju/joueur de continuer
                }
            }


            function drawPlayerFancy(x, y) {
                ctx.save();

                // ========= TRAIL / CHALEUR (capsules) =========
                if (playerTrail.length >= 2) {
                    for (let i = 0; i < playerTrail.length - 1; i++) {
                        const a = playerTrail[i];
                        const b = playerTrail[i + 1];
                        const t = a.life; // 1 -> 0

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const ang = Math.atan2(dy, dx);
                        const dist = Math.hypot(dx, dy);

                        // capsule = un rectangle arrondi avec rotation
                        ctx.save();
                        ctx.translate(a.x, a.y);
                        ctx.rotate(ang);

                        const w = Math.max(22, dist);
                        const h = 26;

                        // glow
                        ctx.fillStyle = `rgba(180, 80, 255, ${0.38 * t})`;
                        roundRectFill(-w * 0.2, -h / 2, w, h, 999);

                        // coeur clair
                        ctx.fillStyle = `rgba(200, 160, 255, ${0.10 * t})`;
                        roundRectFill(-w * 0.1, -h * 0.35, w * 0.75, h * 0.7, 999);

                        ctx.restore();
                    }
                }

                // ========= HALO EXTERNE =========
                ctx.fillStyle = "rgba(160, 60, 255, 0.18)";
                ctx.beginPath();
                ctx.arc(x, y, 44, 0, Math.PI * 2);
                ctx.fill();

                // ========= BOULE =========
                ctx.fillStyle = "#a03cff";
                ctx.beginPath();
                ctx.arc(x, y, 22, 0, Math.PI * 2);
                ctx.fill();

                // ========= √âTOILE LUMINEUSE =========
                drawStar(x, y, 10, 22, 12, "rgba(40,0,255,0.95)");
                drawStar(x, y, 6, 16, 12, "rgba(255,255,255,0.35)");

                // petit reflet
                ctx.fillStyle = "rgba(255,255,255,0.55)";
                ctx.beginPath();
                ctx.arc(x - 6, y - 7, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // √©toile
            function drawStar(cx, cy, innerR, outerR, spikes, color) {
                ctx.save();
                ctx.fillStyle = color;
                ctx.beginPath();

                let rot = -Math.PI / 2;
                const step = Math.PI / spikes;

                ctx.moveTo(cx, cy - outerR);
                for (let i = 0; i < spikes; i++) {
                    ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
                    rot += step;
                    ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
                    rot += step;
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // rectangle arrondi simple
            function roundRectFill(x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
                ctx.fill();
            }
            let energyFX = []; // effets visuels de ramassage

            function spawnEnergyPop(x, y) {
                // anneau + particules
                energyFX.push({
                    x, y,
                    t: 0,
                    duration: 0.45,
                    sparks: Array.from({ length: 10 }, () => {
                        const a = Math.random() * Math.PI * 2;
                        const sp = 160 + Math.random() * 220;
                        return { vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, r: 2 + Math.random() * 2 };
                    })
                });
            }

            function updateEnergyFX(dt) {
                for (const fx of energyFX) fx.t += dt;
                energyFX = energyFX.filter(fx => fx.t < fx.duration);
            }

            function drawEnergyFX() {
                for (const fx of energyFX) {
                    const p = fx.t / fx.duration;       // 0 -> 1
                    const a = 1 - p;                    // fade out

                    // anneau pop
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";
                    ctx.strokeStyle = `rgba(0,255,160,${0.9 * a})`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, 18 + p * 55, 0, Math.PI * 2);
                    ctx.stroke();

                    // petit flash
                    ctx.fillStyle = `rgba(220,255,245,${0.20 * a})`;
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, 22 + p * 35, 0, Math.PI * 2);
                    ctx.fill();

                    // sparks
                    for (const s of fx.sparks) {
                        const sx = fx.x + s.vx * fx.t * 0.018;
                        const sy = fx.y + s.vy * fx.t * 0.018;
                        ctx.fillStyle = `rgba(0,255,160,${0.85 * a})`;
                        ctx.beginPath();
                        ctx.arc(sx, sy, s.r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.globalCompositeOperation = "source-over";

                    // +1 flottant
                    ctx.fillStyle = `rgba(190,255,225,${0.95 * a})`;
                    ctx.font = "bold 18px system-ui";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("+1", fx.x, fx.y - 30 - p * 22);

                    ctx.restore();
                }
            }
            function drawDeathExplosion() {
                if (!DEATHFX.on) return;

                const t = Math.min(1, DEATHFX.t / DEATHFX.dur);
                const x = DEATHFX.x, y = DEATHFX.y;

                // easing
                const easeOut = 1 - Math.pow(1 - t, 3);

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // FLASH central
                {
                    const R = 30 + easeOut * 220;
                    const g = ctx.createRadialGradient(x, y, 0, x, y, R);
                    g.addColorStop(0.0, `rgba(255,255,255,${0.85 * (1 - t)})`);
                    g.addColorStop(0.25, `rgba(120,240,255,${0.55 * (1 - t)})`);
                    g.addColorStop(1.0, `rgba(0,180,255,0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, R, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ONDE DE CHOC (anneau)
                {
                    const R = 60 + easeOut * 300;
                    ctx.strokeStyle = `rgba(180,245,255,${0.55 * (1 - t)})`;
                    ctx.lineWidth = 18 * (1 - t) + 2;
                    ctx.beginPath();
                    ctx.arc(x, y, R, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // PARTICULES (explosion en √©toiles)
                {
                    const count = 26;
                    for (let i = 0; i < count; i++) {
                        const a = (i / count) * Math.PI * 2;
                        const sp = 120 + i * 6;
                        const px = x + Math.cos(a) * easeOut * sp;
                        const py = y + Math.sin(a) * easeOut * sp;

                        ctx.fillStyle = `rgba(200,255,255,${0.65 * (1 - t)})`;
                        ctx.beginPath();
                        ctx.arc(px, py, 6 * (1 - t) + 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();

                // petit voile sombre (impact)
                ctx.save();
                ctx.fillStyle = `rgba(0,0,0,${0.25 * t})`;
                ctx.fillRect(-99999, -99999, 200000, 200000);
                ctx.restore();
            }
            function drawVictoryFX() {
                if (!WINFX.on) return;

                const t = Math.min(1, WINFX.t / WINFX.dur);
                const x = WINFX.x, y = WINFX.y;

                const easeOut = 1 - Math.pow(1 - t, 3);
                const pulse = Math.sin(performance.now() * 0.02) * 0.5 + 0.5;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // FLASH √©norme vert
                {
                    const R = 80 + easeOut * 560;
                    const g = ctx.createRadialGradient(x, y, 0, x, y, R);
                    g.addColorStop(0.0, `rgba(255,255,255,${0.85 * (1 - t)})`);
                    g.addColorStop(0.25, `rgba(120,255,180,${0.55 * (1 - t)})`);
                    g.addColorStop(1.0, `rgba(0,255,160,0)`);
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, R, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Onde de choc (anneau g√©ant)
                {
                    const R = 120 + easeOut * 720;
                    ctx.strokeStyle = `rgba(120,255,200,${0.55 * (1 - t)})`;
                    ctx.lineWidth = 22 * (1 - t) + 4;
                    ctx.beginPath();
                    ctx.arc(x, y, R, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Particules √©toiles
                {
                    const count = 40;
                    for (let i = 0; i < count; i++) {
                        const a = (i / count) * Math.PI * 2;
                        const sp = 160 + i * 8;
                        const px = x + Math.cos(a) * easeOut * sp;
                        const py = y + Math.sin(a) * easeOut * sp;

                        ctx.fillStyle = `rgba(200,255,230,${0.75 * (1 - t)})`;
                        ctx.beginPath();
                        ctx.arc(px, py, 7 * (1 - t) + 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Pulse int√©rieur ‚Äú√©nergie‚Äù
                {
                    const R = 34 + pulse * 8;
                    ctx.strokeStyle = `rgba(255,255,255,${0.35 + pulse * 0.25})`;
                    ctx.lineWidth = 10 + pulse * 10;
                    ctx.beginPath();
                    ctx.arc(x, y, R, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();

                // l√©ger voile clair (glow victory)
                ctx.save();
                ctx.fillStyle = `rgba(0,255,160,${0.10 * (1 - t)})`;
                ctx.fillRect(-99999, -99999, 200000, 200000);
                ctx.restore();
            }
            // ====== Draw ======
            function draw() {
                resizeCanvasToDisplaySize();
                update();
                // NE PAS remplir en blanc : le CSS du canvas fait le fond
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const { ox, oy } = getCenterOffset();
                ctx.save();
                ctx.translate(ox, oy);
                // tremblement cam√©ra
                if (screenShake > 0.2) {
                    const sx = (Math.random() * 2 - 1) * screenShake;
                    const sy = (Math.random() * 2 - 1) * screenShake;
                    ctx.translate(sx, sy);
                }

                // edges
                for (const [aId, bId] of edges) {
                    const a = getNode(aId);
                    const b = getNode(bId);
                    if (!a || !b) continue;

                    ctx.lineCap = "round";

                    ctx.strokeStyle = "rgba(0,0,0,0.55)";
                    ctx.lineWidth = EDGE_WIDTH + 4;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();

                    ctx.strokeStyle = "rgba(140,140,140,0.45)";
                    ctx.lineWidth = EDGE_WIDTH;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }

                // nodes
                for (const n of nodes) {
                    const isHovered = n.id === hoveredId;
                    const isSelected = n.id === selectedId;

                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = "rgba(90,90,90,0.85)";
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();

                    if (isHovered || isSelected) {
                        ctx.strokeStyle = isSelected ? "#00d1ff" : "#ffd166";
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, NODE_RADIUS + 8, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = "rgba(0,0,0,0.55)";
                    ctx.font = "bold 16px system-ui";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(String(n.id), n.x, n.y);
                }

                function drawEnergyModule() {
                    if (ENERGY.nodeId === null) return;
                    const n = getNode(ENERGY.nodeId);
                    if (!n) return;

                    // halo
                    ctx.fillStyle = "rgba(0,255,160,0.25)";
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 18, 0, Math.PI * 2);
                    ctx.fill();

                    // module (petit losange)
                    ctx.fillStyle = "#00ff9a";
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y - 16);
                    ctx.lineTo(n.x + 16, n.y);
                    ctx.lineTo(n.x, n.y + 16);
                    ctx.lineTo(n.x - 16, n.y);
                    ctx.closePath();
                    ctx.fill();

                    // petit reflet
                    ctx.fillStyle = "rgba(255,255,255,0.6)";
                    ctx.beginPath();
                    ctx.arc(n.x - 6, n.y - 6, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                drawBorderWarning(); // warning AU-DESSUS du terrain
                drawFireball();      // boule AU-DESSUS
                drawBombWarning();
                drawBombExplosion();
                drawKaiju();
                drawEnergyModule();
                drawEnergyFX();
                drawPlayerFancy(playerPos.x, playerPos.y);
                drawDeathExplosion();
                drawVictoryFX();

                // texte √©dition
                if (editMode) {
                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.font = "14px system-ui";
                    ctx.textAlign = "left";
                    ctx.fillText("Mode √©dition ON : drag pour bouger une case", 14, 24);
                    ctx.fillText("Touche F : tir horizontal | Shift+F : tir vertical", 14, 44);
                } else {
                    ctx.fillStyle = "rgba(0,0,0,0.55)";
                    ctx.font = "14px system-ui";
                    ctx.textAlign = "left";
                    ctx.fillText("Touche F : tir horizontal | Shift+F : tir vertical", 14, 24);
                }

                ctx.restore();
                //jeu terminer
                // ===== MESSAGE FIN (apr√®s d√©lais) =====
                if (gameOver && loseTextDelay <= 0) {
                    ctx.fillStyle = "rgba(0,0,0,0.45)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = "#fff";
                    ctx.font = "bold 54px Cinzel, serif";
                    ctx.textAlign = "center";

                    ctx.fillText("T'AS PERDU", canvas.width / 2, canvas.height / 2 - 15);

                    ctx.font = "18px Cinzel, serif";
                    ctx.fillStyle = "rgba(255,255,255,0.9)";
                    ctx.fillText(gameOverMsg, canvas.width / 2, canvas.height / 2 + 22);

                }

                if (gameWon && winTextDelay <= 0) {
                    ctx.fillStyle = "rgba(0,0,0,0.35)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = "#fff";
                    ctx.font = "bold 58px Cinzel, serif";
                    ctx.textAlign = "center";

                    ctx.fillText("TU AS GAGN√â !", canvas.width / 2, canvas.height / 2 - 10);

                    ctx.font = "18px Cinzel, serif";
                    ctx.fillStyle = "rgba(255,255,255,0.9)";
                    ctx.fillText(endMsg, canvas.width / 2, canvas.height / 2 + 28);

                }
                requestAnimationFrame(draw);
            }
            //feu aleratoire
            function startRandomFireAttack() {
                if (FIRE.state !== "idle" || gameOver || gameWon) return;

                const axis = Math.random() < 0.5 ? "h" : "v";
                FIRE.axis = axis;

                const b = getPlayBounds();

                if (axis === "h") {
                    FIRE.lineY = b.top + Math.random() * (b.bottom - b.top);
                    FIRE.lineX = playerPos.x;
                } else {
                    FIRE.lineX = b.left + Math.random() * (b.right - b.left);
                    FIRE.lineY = playerPos.y;
                }

                FIRE.state = "warning";
                FIRE.t = 0;
                FIRE.blinkStep = 0;
                FIRE.visible = true;
                FIRE.projectile = null;
            }

            // ====== Events ======
            canvas.addEventListener("mousemove", (e) => {
                const { x, y } = getMousePos(e);
                hoveredId = hitNode(x, y);
                if (uiHovered) uiHovered.textContent = hoveredId ?? "-";
                //uiHovered.textContent = hoveredId ?? "-";

                if (editMode && draggingId !== null) {
                    const n = getNode(draggingId);
                    if (n) {
                        n.x = x - dragOffset.x;
                        n.y = y - dragOffset.y;

                        // si on d√©place la case du joueur (et pas en mouvement)
                        if (n.id === playerNodeId && !isMoving) {
                            playerPos.x = n.x; playerPos.y = n.y;
                            playerTarget.x = n.x; playerTarget.y = n.y;
                        }
                    }
                }
            });

            canvas.addEventListener("mousedown", (e) => {
                const { x, y } = getMousePos(e);
                const id = hitNode(x, y);

                if (editMode) {
                    if (id !== null) {
                        draggingId = id;
                        const n = getNode(id);
                        dragOffset.x = x - n.x;
                        dragOffset.y = y - n.y;
                    }
                    return;
                }

                if (id !== null) {
                    selectedId = id;
                    if (uiSelected) uiSelected.textContent = String(selectedId);
                    movePlayerTo(id);
                }
            });

            window.addEventListener("mouseup", () => {
                draggingId = null;
            });

            btnToggleEdit.addEventListener("click", () => {
                setEditMode(!editMode);
            });

            btnReset.addEventListener("click", () => {
                resetPositions();
            });

            window.addEventListener("keydown", (e) => {
                if (e.code === "KeyR") {
                    gameOver = false;
                    gameOverMsg = "";
                    playerNodeId = 1;
                    initPlayer();
                    initKaijuSpawnSystem();
                    BOMB.state = "idle";
                    FIRE.state = "idle";
                }
            });

            // init
            setEditMode(false);
            initPlayer();
            initKaijuSpawnSystem();
            energyUI.textContent = "0";
            spawnEnergyModule();
            draw();
        })();





    </script>


</body>

</html>