<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kaiju ‚Äî Terrain</title>

    <style>
        :root {
            --text: #eef0ff;
            --muted: rgba(238, 240, 255, .72);
            --stroke: rgba(255, 255, 255, .10);
            --shadow: rgba(0, 0, 0, .55);
            --panel: rgba(0, 0, 0, .40);
            --panel2: rgba(255, 255, 255, .06);

            --green: #31d07a;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            color: var(--text);
            background: #000;
            overflow: hidden;
        }

        /* Fond global noir + halo rouge au milieu */
        body::before {
            content: "";
            position: fixed;
            inset: -30vmax;
            background:
                radial-gradient(60vmax 40vmax at 50% 55%,
                    rgba(140, 0, 0, .40) 0%,
                    rgba(70, 0, 0, .22) 35%,
                    rgba(0, 0, 0, 0) 70%),
                radial-gradient(70vmax 70vmax at 50% 50%,
                    rgba(0, 0, 0, 0) 55%,
                    rgba(0, 0, 0, .50) 78%,
                    rgba(0, 0, 0, .85) 100%);
            pointer-events: none;
            z-index: -2;
        }

        /* Layout plein √©cran */
        .app {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Barre UI en haut */
        .hud {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 16px;
        }

        .hud-left,
        .hud-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .pill {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            border-radius: 999px;
            background: var(--panel);
            border: 1px solid var(--stroke);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, .06),
                0 14px 40px var(--shadow);
            color: var(--muted);
            line-height: 1;
            min-height: 42px;
            backdrop-filter: blur(6px);
        }

        .objective {
            min-width: min(560px, 68vw);
            justify-content: flex-start;
            font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
            font-size: 22px;
            color: rgba(255, 255, 255, .90);
            letter-spacing: .2px;
        }

        .energy {
            padding-right: 16px;
        }

        .gem {
            width: 18px;
            height: 18px;
            background: var(--green);
            border-radius: 6px;
            transform: rotate(45deg);
            box-shadow: 0 0 0 4px rgba(49, 208, 122, .10);
            flex: 0 0 auto;
        }

        .btn {
            cursor: pointer;
            border: 1px solid var(--stroke);
            background: var(--panel);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 999px;
            font-weight: 800;
            letter-spacing: .2px;
            min-height: 42px;
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, .06),
                0 14px 40px var(--shadow);
            backdrop-filter: blur(6px);
        }

        .btn:hover {
            background: rgba(0, 0, 0, .55);
        }

        /* Zone jeu = tout le reste de la page */
        .stage {
            flex: 1 1 auto;
            padding: 10px 16px 16px;
            min-height: 0;
            /* IMPORTANT pour √©viter que √ßa d√©borde/coupe */
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 14px;
            /* ton background rouge/noir */
        }

        @media (max-width: 720px) {
            .objective {
                font-size: 18px;
                min-width: 0;
            }

            .pill,
            .btn {
                min-height: 40px;
                padding: 9px 12px;
            }
        }
        .energyStack{
  display:flex;
  flex-direction:column;
  gap:6px;
  min-width:120px;
}

.energyNums{
  display:flex;
  align-items:baseline;
  gap:6px;
}

.energyBar{
  width:140px;
  height:8px;
  border-radius:999px;
  background:rgba(255,255,255,0.10);
  overflow:hidden;
  border:1px solid rgba(255,255,255,0.10);
}

.energyFill{
  height:100%;
  width:0%;
  border-radius:999px;
  background:rgba(49,208,122,0.95);
  box-shadow: 0 0 14px rgba(49,208,122,0.55);
  transition: width 180ms ease;
}
    </style>
</head>

<body>
    <div class="app">

        <!-- UI TOP -->
        <div class="hud">
            <div class="hud-left">
                <div class="pill objective">
                    Objectif : r√©cup√©rer les 15 modules d‚Äô√©nergie.
                </div>
            </div>

            <div class="hud-right">
                <div class="pill energy" id="energyPill">
                    <span class="gem" aria-hidden="true"></span>

                    <div class="energyStack">
                        <div class="energyNums"><b id="energy">0</b><span style="opacity:.65;"></span></div>

                        <div class="energyBar" aria-hidden="true">
                            <div class="energyFill" id="energyFill"></div>
                        </div>
                    </div>
                </div>
                <button class="btn" id="toggleEdit">Mode √©dition: OFF</button>
                <button class="btn" id="reset">Reset positions</button>
            </div>
        </div>

        <!-- GAME FULL -->
        <div class="stage">
            <canvas id="game" width="1280" height="720"></canvas>
        </div>

    </div>



    <script>
        (() => {
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");
            const kaijuImg = new Image();
            kaijuImg.src = "image/tete_de_kaijo.png";
            function resizeCanvasToDisplaySize() {
                const r = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                const w = Math.round(r.width * dpr);
                const h = Math.round(r.height * dpr);

                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                }
            }

            window.addEventListener("resize", resizeCanvasToDisplaySize);

            const uiHovered = document.getElementById("hovered");   // peut √™tre null
            const uiSelected = document.getElementById("selected"); // peut √™tre null
            const btnToggleEdit = document.getElementById("toggleEdit");
            const btnReset = document.getElementById("reset");

            let gameOver = false;
            let gameWon = false;
            let gameOverMsg = "";

            const energyUI = document.getElementById("energy");
            function updateEnergyUI() {
                energyUI.textContent = `${ENERGY.collected}/${ENERGY.goal}`;
                const p = Math.max(0, Math.min(1, ENERGY.collected / ENERGY.goal));
                if (energyFill) energyFill.style.width = `${p * 100}%`;
            }

            const ENERGY = {
                collected: 0,
                goal: 15,
                nodeId: null,   // case o√π se trouve le module
            };

            let nextFireIn = 2.0; // premi√®re attaque apr√®s 2 sec

            let bombTimer = 10.0;     // premi√®re bombe apr√®s 10s
            const BOMB_INTERVAL = 3.0; // ensuite toutes les 3s
            // ====== TERRAIN ======
            const initialNodes = [
                { id: 0, x: 220, y: 520 },
                { id: 1, x: 320, y: 250 },
                { id: 2, x: 430, y: 390 },
                { id: 3, x: 520, y: 160 },
                { id: 4, x: 590, y: 600 },
                { id: 5, x: 650, y: 330 },
                { id: 6, x: 760, y: 250 },
                { id: 7, x: 880, y: 160 },
                { id: 8, x: 980, y: 280 },
                { id: 9, x: 910, y: 420 },
                { id: 10, x: 1120, y: 520 },
            ];

            const edges = [
                [0, 1], [0, 2], [0, 4],
                [1, 2], [1, 3],
                [2, 3], [2, 5],
                [5, 6], [5, 9],
                [6, 7],
                [7, 8],
                [8, 9], [8, 10],
                [9, 10],
                [4, 10],
            ];

            let nodes = initialNodes.map(n => ({ ...n }));
            function getNodesBounds() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const n of nodes) {
                    minX = Math.min(minX, n.x); minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x); maxY = Math.max(maxY, n.y);
                }
                return { minX, minY, maxX, maxY };
            }

            function getCenterOffset() {
                const b = getNodesBounds();
                const cx = (b.minX + b.maxX) / 2;
                const cy = (b.minY + b.maxY) / 2;
                return { ox: canvas.width / 2 - cx, oy: canvas.height / 2 - cy };
            }

            // ====== ADJ (voisins) ======
            const adj = new Map();
            for (const n of initialNodes) adj.set(n.id, []);
            for (const [a, b] of edges) {
                adj.get(a).push(b);
                adj.get(b).push(a);
            }

            // ====== UI / Interaction ======
            let hoveredId = null;
            let selectedId = null;

            let editMode = false;
            let draggingId = null;
            let dragOffset = { x: 0, y: 0 };

            const NODE_RADIUS = 28;
            const EDGE_WIDTH = 10;

            function setEditMode(on) {
                editMode = on;
                btnToggleEdit.textContent = `Mode √©dition: ${editMode ? "ON" : "OFF"}`;
            }

            function resetPositions() {
                nodes = initialNodes.map(n => ({ ...n }));
                initPlayer();
                initKaijuSpawnSystem();
                ENERGY.collected = 0;
                energyUI.textContent = "0";
                spawnEnergyModule();
            }

            // ====== Helpers ======
            function dist2(ax, ay, bx, by) {
                const dx = ax - bx, dy = ay - by;
                return dx * dx + dy * dy;
            }

            function getMousePos(evt) {
                const r = canvas.getBoundingClientRect();
                const scaleX = canvas.width / r.width;
                const scaleY = canvas.height / r.height;

                const { ox, oy } = getCenterOffset(); // important: centrage

                return {
                    x: (evt.clientX - r.left) * scaleX - ox,
                    y: (evt.clientY - r.top) * scaleY - oy
                };
            }

            function hitNode(mx, my) {
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const n = nodes[i];
                    if (dist2(mx, my, n.x, n.y) <= NODE_RADIUS * NODE_RADIUS) return n.id;
                }
                return null;
            }

            function getNode(id) { return nodes.find(n => n.id === id); }


            //Fonction pour faire appara√Ætre un module sur une case al√©atoire
            function randomInt(max) { return Math.floor(Math.random() * max); }

            function spawnEnergyModule() {
                let newId;

                do {
                    newId = nodes[Math.floor(Math.random() * nodes.length)].id;
                } while (
                    newId === ENERGY.nodeId ||   // pas la m√™me case
                    newId === playerNodeId       // pas sous le joueur
                );

                ENERGY.nodeId = newId;
            }

            function collectEnergyIfOnNode() {
                if (ENERGY.nodeId === null || gameWon) return;

                if (playerNodeId === ENERGY.nodeId) {
                    ENERGY.collected++;
                    const n = getNode(ENERGY.nodeId);
if (n) spawnEnergyPop(n.x, n.y);
updateEnergyUI();
                    energyUI.textContent = `${ENERGY.collected}/${ENERGY.goal}`;

                    if (ENERGY.collected >= ENERGY.goal) {
                        gameWon = true;
                        //endMsg = `Bravo üéâ Tu as collect√© ${ENERGY.collected} modules d'√©nergie !`;
                    } else {
                        spawnEnergyModule(); // üîÅ change vraiment de case
                    }
                }
            }

            // ====== JOUEUR ======
            let playerNodeId = 1;
            let playerPos = { x: 0, y: 0 };
            let playerTarget = { x: 0, y: 0 };
            let isMoving = false;
            let playerTrail = []; // tra√Æn√©e (positions)
            const TRAIL_MAX = 14;

            const PLAYER_SPEED = 520; // px/s

            function initPlayer() {
                const start = getNode(playerNodeId);
                playerPos.x = start.x; playerPos.y = start.y;
                playerTarget.x = start.x; playerTarget.y = start.y;
                isMoving = false;
            }

            function canMoveTo(fromId, toId) {
                return adj.get(fromId)?.includes(toId);
            }

            function movePlayerTo(nodeId) {
                if (isMoving) return;
                if (!canMoveTo(playerNodeId, nodeId)) return;

                const dest = getNode(nodeId);
                if (!dest) return;

                isMoving = true;
                playerNodeId = nodeId;
                playerTarget.x = dest.x;
                playerTarget.y = dest.y;
            }

            // ====== KAIJU (spawn sur case 10, chase 7s, respawn timer) ======********************************************************************
            const KAIJU = {
                state: "idle",      // "idle" | "warning" | "active"
                nodeId: 10,
                pos: { x: 0, y: 0 },
                target: { x: 0, y: 0 },
                moving: false,

                // timers
                spawnIn: 25.0,      // 1√®re apparition apr√®s 30s
                nextInterval: 10.0, // ensuite toutes les 15s
                activeLeft: 0,      // temps restant en chase

                // warning blink
                wT: 0,
                wStep: 0,           // 0 ON, 1 OFF, 2 ON
                wVisible: true,
            };
            let kaijuTrail = [];
            const KTRAIL_MAX = 18; // + grand = plus long
            const KAIJU_WARN_ON = 0.5;
            const KAIJU_WARN_OFF = 0.5;
            const KAIJU_ACTIVE_DURATION = 8.0;         // chase 8s
            const KAIJU_SPEED = PLAYER_SPEED * 0.7;   // presque pareil que joueur 
            let kaijuStepTimer = 0.0;                  // tempo d√©cision de pas

            function initKaijuSpawnSystem() {
                KAIJU.state = "idle";
                KAIJU.spawnIn = 25.0;
                KAIJU.activeLeft = 0;
                KAIJU.moving = false;

                const start = getNode(10);
                KAIJU.pos.x = start.x; KAIJU.pos.y = start.y;
                KAIJU.target.x = start.x; KAIJU.target.y = start.y;
            }

            // plus court chemin: renvoie le "prochain pas" vers goal
            function bfsNextStep(startId, goalId) {
                if (startId === goalId) return startId;

                const q = [startId];
                const prev = new Map();
                prev.set(startId, null);

                while (q.length) {
                    const cur = q.shift();
                    for (const nb of (adj.get(cur) || [])) {
                        if (prev.has(nb)) continue;
                        prev.set(nb, cur);

                        if (nb === goalId) {
                            // remonter jusqu'au premier pas
                            let step = nb;
                            let p = prev.get(step);
                            while (p !== startId && p !== null) {
                                step = p;
                                p = prev.get(step);
                            }
                            return step;
                        }
                        q.push(nb);
                    }
                }
                return startId;
            }

            function startKaijuWarning() {
                // place kaiju sur node 10 (sans √™tre visible "active" encore)
                KAIJU.nodeId = 10;
                const n = getNode(10);
                KAIJU.pos.x = n.x; KAIJU.pos.y = n.y;
                KAIJU.target.x = n.x; KAIJU.target.y = n.y;
                KAIJU.moving = false;

                KAIJU.state = "warning";
                KAIJU.wT = 0;
                KAIJU.wStep = 0;
                KAIJU.wVisible = true;
            }

            function startKaijuActive() {
                KAIJU.state = "active";
                KAIJU.activeLeft = KAIJU_ACTIVE_DURATION;
                kaijuStepTimer = 0.0;
            }

            function hideKaiju() {
                KAIJU.state = "idle";
                KAIJU.moving = false;
                KAIJU.activeLeft = 0;
            }

            function updateKaiju(dt) {
                if (gameOver) return;

                // timer spawn global
                if (KAIJU.state === "idle") {
                    KAIJU.spawnIn -= dt;
                    if (KAIJU.spawnIn <= 0) {
                        startKaijuWarning();
                        // pr√©pare le prochain spawn (dans 20s) ‚Äî on le remettra apr√®s fin de chase
                        KAIJU.spawnIn = KAIJU.nextInterval;
                    }
                    return;
                }

                // warning blink 2 fois
                if (KAIJU.state === "warning") {
                    KAIJU.wT += dt;

                    if (KAIJU.wStep === 0) {
                        KAIJU.wVisible = true;
                        if (KAIJU.wT >= KAIJU_WARN_ON) { KAIJU.wT = 0; KAIJU.wStep = 1; }
                    } else if (KAIJU.wStep === 1) {
                        KAIJU.wVisible = false;
                        if (KAIJU.wT >= KAIJU_WARN_OFF) { KAIJU.wT = 0; KAIJU.wStep = 2; }
                    } else {
                        KAIJU.wVisible = true;
                        if (KAIJU.wT >= KAIJU_WARN_ON) {
                            startKaijuActive();
                        }
                    }
                    return;
                }

                // active chase
                if (KAIJU.state === "active") {
                    KAIJU.activeLeft -= dt;
                    if (KAIJU.activeLeft <= 0) {
                        hideKaiju();
                        return;
                    }

                    // d√©cide un pas toutes les ~0.8s (ajuste)
                    kaijuStepTimer -= dt;
                    if (kaijuStepTimer <= 0 && !KAIJU.moving) {
                        const next = bfsNextStep(KAIJU.nodeId, playerNodeId);
                        if (next !== KAIJU.nodeId) {
                            const dest = getNode(next);
                            KAIJU.nodeId = next;
                            KAIJU.target.x = dest.x;
                            KAIJU.target.y = dest.y;
                            KAIJU.moving = true;
                        }
                        kaijuStepTimer = 0.6 + Math.random() * 0.4; // 0.6‚Äì1.0s
                    }

                    // animation d√©placement kaiju
                    if (KAIJU.moving) {
                        // Trail (chaleur) pendant le mouvement
                        kaijuTrail.push({ x: KAIJU.pos.x, y: KAIJU.pos.y, life: 1 });
                        if (kaijuTrail.length > KTRAIL_MAX) kaijuTrail.shift();
                        const dx = KAIJU.target.x - KAIJU.pos.x;
                        const dy = KAIJU.target.y - KAIJU.pos.y;
                        const dist = Math.hypot(dx, dy);
                        const step = KAIJU_SPEED * dt;

                        if (dist <= step) {
                            KAIJU.pos.x = KAIJU.target.x;
                            KAIJU.pos.y = KAIJU.target.y;
                            KAIJU.moving = false;

                            // si kaiju arrive sur la case du joueur -> perdu
                            if (KAIJU.nodeId === playerNodeId) {
                                killPlayer("Le Kaiju t'a rattrap√© !");
                            }
                        } else {
                            KAIJU.pos.x += (dx / dist) * step;
                            KAIJU.pos.y += (dy / dist) * step;
                        }
                        // Fade de la trail (plus lente = plus visible)
                        for (const p of kaijuTrail) p.life -= dt * 1.1;
                        kaijuTrail = kaijuTrail.filter(p => p.life > 0);
                    }
                }
            }

            function drawKaiju() {
                if (KAIJU.state === "idle") return;

                const x = KAIJU.pos.x;
                const y = KAIJU.pos.y;

                ctx.save();

                // ===== TRAIL BLEUE (forte + contrast√©e) =====
                if (kaijuTrail.length >= 2) {
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";

                    for (let i = 0; i < kaijuTrail.length - 1; i++) {
                        const a = kaijuTrail[i];
                        const b = kaijuTrail[i + 1];
                        const t = a.life; // 1 -> 0

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const ang = Math.atan2(dy, dx);
                        const dist = Math.hypot(dx, dy);

                        ctx.save();
                        ctx.translate(a.x, a.y);
                        ctx.rotate(ang);

                        const w = Math.max(30, dist * 1.2);
                        const h = 34;

                        // couche externe (bleu intense)
                        ctx.fillStyle = `rgba(0, 170, 255, ${0.55 * t})`;
                        roundRectFill(-w * 0.25, -h / 2, w, h, 999);

                        // coeur (presque blanc)
                        ctx.fillStyle = `rgba(220, 250, 255, ${0.22 * t})`;
                        roundRectFill(-w * 0.12, -h * 0.32, w * 0.78, h * 0.64, 999);

                        ctx.restore();
                    }

                    ctx.globalCompositeOperation = "source-over";
                    ctx.restore();
                }

                // ===== HALO BLEU AUTOUR (plus fort si bouge) =====
                const heat = KAIJU.moving ? 1.2 : 0.7;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                ctx.fillStyle = `rgba(0, 170, 255, ${0.22 * heat})`;
                ctx.beginPath();
                ctx.arc(x, y, 60 * heat, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(0, 120, 255, ${0.16 * heat})`;
                ctx.beginPath();
                ctx.arc(x, y, 42 * heat, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();

                // ===== IMAGE KAIJU =====
                const size = 120;
                ctx.drawImage(kaijuImg, x - size / 2, y - size / 2, size, size);

                ctx.restore();
            }

            // ====== ATTAQUE FEU (bordure -> ligne -> projectile) ======*******************************************************************************

            const FIRE = {
                state: "idle",    // "idle" | "warning" | "firing"
                axis: "h",        // "h" ou "v"
                lineX: 0,
                lineY: 0,
                t: 0,
                blinkStep: 0,     // 0 ON, 1 OFF, 2 ON
                visible: true,
                projectile: null, // {x,y,vx,vy}
            };

            const WARN_ON = 0.5;
            const WARN_OFF = 0.5;
            const FIRE_SPEED = PLAYER_SPEED * 1.6;  // ~ vitesse joueur
            const FIRE_RADIUS = 40;           // üî• plus gros (augmente si tu veux)
            const PLAYER_RADIUS = 18;
            const WARNING_SCALE = 2.4;              // ‚ö†Ô∏è ic√¥ne plus grande
            function startFireAttack(axis) {


                FIRE.axis = axis;

                // Important: on "verrouille" la ligne au moment du warning (sinon √ßa bouge trop)
                FIRE.lineX = playerPos.x;
                FIRE.lineY = playerPos.y;

                FIRE.state = "warning";
                FIRE.t = 0;
                FIRE.blinkStep = 0;
                FIRE.visible = true;
                FIRE.projectile = null;
            }
            // ===== LIMITES DU TERRAIN (zone bleue) =====
            function getPlayBounds() {
                // limites bas√©es sur ton graphe (terrain), pas sur l'√©cran
                const b = getNodesBounds();
                const pad = 80; // marge autour du graphe (augmente/diminue)

                return {
                    left: b.minX - pad,
                    right: b.maxX + pad,
                    top: b.minY - pad,
                    bottom: b.maxY + pad
                };
            }

            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }

            function spawnProjectile() {
                const b = getPlayBounds();

                FIRE.lineX = clamp(FIRE.lineX, b.left, b.right);
                FIRE.lineY = clamp(FIRE.lineY, b.top, b.bottom);

                const off = 220; // distance hors terrain avant d'entrer

                if (FIRE.axis === "h") {
                    const fromLeft = Math.random() < 0.5;
                    FIRE.projectile = {
                        x: fromLeft ? b.left - off : b.right + off,
                        y: FIRE.lineY,
                        vx: fromLeft ? FIRE_SPEED : -FIRE_SPEED,
                        vy: 0
                    };
                } else {
                    const fromTop = Math.random() < 0.5;
                    FIRE.projectile = {
                        x: FIRE.lineX,
                        y: fromTop ? b.top - off : b.bottom + off,
                        vx: 0,
                        vy: fromTop ? FIRE_SPEED : -FIRE_SPEED
                    };
                }
            }

            function killPlayer(reason) {
                gameOver = true;
                gameOverMsg = "T'as perdu üòµ ‚Äî " + reason;

                // stop feu
                FIRE.state = "idle";
                FIRE.projectile = null;

                // stop mouvement
                isMoving = false;
            }

            function updateFire(dt) {

                if (FIRE.state === "idle") return;

                if (FIRE.state === "warning") {
                    FIRE.t += dt;

                    if (FIRE.blinkStep === 0) {
                        FIRE.visible = true;
                        if (FIRE.t >= WARN_ON) { FIRE.t = 0; FIRE.blinkStep = 1; }
                    } else if (FIRE.blinkStep === 1) {
                        FIRE.visible = false;
                        if (FIRE.t >= WARN_OFF) { FIRE.t = 0; FIRE.blinkStep = 2; }
                    } else {
                        FIRE.visible = true;
                        if (FIRE.t >= WARN_ON) {
                            FIRE.state = "firing";
                            spawnProjectile();
                        }
                    }
                    return;
                }

                // firing
                const p = FIRE.projectile;
                if (!p) { FIRE.state = "idle"; return; }

                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // collision joueur vs boule de feu
                const d = Math.hypot(playerPos.x - p.x, playerPos.y - p.y);
                if (d <= (PLAYER_RADIUS + FIRE_RADIUS)) {
                    killPlayer("Touch√© par le feu !");
                }

                // fin quand sort de l'√©cran
                const b = getPlayBounds();
                const out = 260;
                if (p.x < b.left - out || p.x > b.right + out || p.y < b.top - out || p.y > b.bottom + out) {
                    FIRE.state = "idle";
                    FIRE.projectile = null;
                }
            }


            function drawWarningAt(x, y) {
                ctx.save();
                ctx.translate(x, y);

                const s = WARNING_SCALE;

                ctx.fillStyle = "#ffd400";
                ctx.beginPath();
                ctx.moveTo(0, -22 * s);
                ctx.lineTo(22 * s, 18 * s);
                ctx.lineTo(-22 * s, 18 * s);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = "#111";
                ctx.font = `bold ${Math.round(22 * s)}px system-ui`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("!", 0, 4 * s);

                ctx.restore();
            }
            function drawBorderWarning() {
                if (FIRE.state !== "warning" || !FIRE.visible) return;

                const b = getPlayBounds();

                ctx.save();
                ctx.strokeStyle = "rgba(255,0,0,0.35)";
                ctx.lineWidth = 8;
                ctx.lineCap = "round";

                if (FIRE.axis === "h") {
                    const y = FIRE.lineY;
                    ctx.beginPath();
                    ctx.moveTo(b.left, y);
                    ctx.lineTo(b.right, y);
                    ctx.stroke();

                    drawWarningAt(b.left, y);
                    drawWarningAt(b.right, y);
                } else {
                    const x = FIRE.lineX;
                    ctx.beginPath();
                    ctx.moveTo(x, b.top);
                    ctx.lineTo(x, b.bottom);
                    ctx.stroke();

                    drawWarningAt(x, b.top);
                    drawWarningAt(x, b.bottom);
                }

                ctx.restore();
            }
            function drawFireballAura(x, y, vx, vy, baseR) {
                const speed = Math.hypot(vx, vy);
                if (speed < 0.01) return;

                const nx = vx / speed;
                const ny = vy / speed;

                const stretch = Math.min(70, speed * 0.22); // longueur aura
                const t = performance.now() * 0.006;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // ===== AURA PRINCIPALE (directionnelle)
                {
                    const g = ctx.createRadialGradient(
                        x - nx * stretch * 0.6,
                        y - ny * stretch * 0.6,
                        baseR * 0.4,
                        x - nx * stretch,
                        y - ny * stretch,
                        baseR + stretch
                    );

                    g.addColorStop(0.0, "rgba(180,245,255,0.45)");
                    g.addColorStop(0.4, "rgba(120,220,255,0.30)");
                    g.addColorStop(1.0, "rgba(0,160,255,0.00)");

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.ellipse(
                        x - nx * stretch * 0.6,
                        y - ny * stretch * 0.6,
                        baseR + stretch * 0.9,
                        baseR * 0.85,
                        Math.atan2(ny, nx),
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                // ===== PULSE CHALEUR
                {
                    const pulse = Math.sin(t * 2.2) * 0.5 + 0.5;
                    const r = baseR + 10 + pulse * 6;

                    ctx.strokeStyle = `rgba(140,230,255,${0.18 + pulse * 0.18})`;
                    ctx.lineWidth = 10 + pulse * 8;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();
            }
            function drawFireball() {
                if (FIRE.state !== "firing" || !FIRE.projectile) return;

                const p = FIRE.projectile;
                const x = p.x, y = p.y;
                drawFireballAura(x, y, p.vx, p.vy, FIRE_RADIUS + 8);

                // Taille visuelle (tu peux ajuster)
                const R = FIRE_RADIUS;          // rayon "hitbox"
                const outer = R + 26;           // halo externe
                const inner = R + 6;            // bord lumineux

                const t = performance.now() * 0.006; // animation

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // ===== HALO EXTERNE (bleu)
                {
                    const g = ctx.createRadialGradient(x, y, 0, x, y, outer);
                    g.addColorStop(0.00, "rgba(220,255,255,0.55)");
                    g.addColorStop(0.35, "rgba(120,235,255,0.35)");
                    g.addColorStop(1.00, "rgba(0,180,255,0.00)");
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, outer, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ===== BORD DENTEL√â (comme ton image)
                {
                    const spikes = 64;        // + = bord plus "cr√©nel√©"
                    const amp = 5.5;          // amplitude des dents
                    ctx.fillStyle = "rgba(120,235,255,0.55)";

                    ctx.beginPath();
                    for (let i = 0; i <= spikes; i++) {
                        const a = (i / spikes) * Math.PI * 2;
                        const wobble = Math.sin(a * 18 + t) * amp + Math.sin(a * 7 - t * 1.2) * (amp * 0.45);
                        const rr = inner + wobble;
                        const px = x + Math.cos(a) * rr;
                        const py = y + Math.sin(a) * rr;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // ===== DISQUE PRINCIPAL (bleu clair)
                {
                    const g2 = ctx.createRadialGradient(x, y, 0, x, y, R + 10);
                    g2.addColorStop(0.00, "rgba(235,255,255,0.98)");
                    g2.addColorStop(0.55, "rgba(170,245,255,0.92)");
                    g2.addColorStop(1.00, "rgba(80,220,255,0.85)");
                    ctx.fillStyle = g2;
                    ctx.beginPath();
                    ctx.arc(x, y, R + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ===== CENTRE plus doux
                {
                    ctx.fillStyle = "rgba(255,255,255,0.25)";
                    ctx.beginPath();
                    ctx.arc(x, y, R * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalCompositeOperation = "source-over";
                ctx.restore();
            }

            // ====== ATTAQUE BOMBE (zone rouge -> explosion) ======***********************************************************************************
            const BOMB = {
                state: "idle",     // "idle" | "warning" | "exploding"
                x: 0,
                y: 0,
                r: 260,            // rayon du cercle rouge (augmente/r√©duit)
                t: 0,
                blinkStep: 0,      // 0 ON, 1 OFF, 2 ON
                visible: true,
                affected: [],      // ids des cases touch√©es
                explosionT: 0,     // timer explosion
            };

            const BOMB_WARN_ON = 0.5;
            const BOMB_WARN_OFF = 0.5;
            const EXPLOSION_DURATION = 0.6; // dur√©e animation explosion

            function pickRandomBombCenter() {
                const n = nodes[Math.floor(Math.random() * nodes.length)];
                return { x: n.x, y: n.y };
            }

            function computeAffectedNodes(cx, cy, radius) {
                const out = [];
                const r2 = radius * radius;
                for (const n of nodes) {
                    const dx = n.x - cx;
                    const dy = n.y - cy;
                    if (dx * dx + dy * dy <= r2) out.push(n.id);
                }
                return out;
            }

            function startBombAttack() {
                if (gameOver) return;
                if (BOMB.state !== "idle") return;       // une bombe √† la fois


                const c = pickRandomBombCenter();
                BOMB.x = c.x;
                BOMB.y = c.y;
                BOMB.affected = computeAffectedNodes(BOMB.x, BOMB.y, BOMB.r);

                BOMB.state = "warning";
                BOMB.t = 0;
                BOMB.blinkStep = 0;
                BOMB.visible = true;
                BOMB.explosionT = 0;
            }

            function updateBomb(dt) {
                if (BOMB.state === "idle") return;

                if (BOMB.state === "warning") {
                    BOMB.t += dt;

                    if (BOMB.blinkStep === 0) {
                        BOMB.visible = true;
                        if (BOMB.t >= BOMB_WARN_ON) { BOMB.t = 0; BOMB.blinkStep = 1; }
                    } else if (BOMB.blinkStep === 1) {
                        BOMB.visible = false;
                        if (BOMB.t >= BOMB_WARN_OFF) { BOMB.t = 0; BOMB.blinkStep = 2; }
                    } else {
                        BOMB.visible = true;
                        if (BOMB.t >= BOMB_WARN_ON) {
                            // BOOM
                            BOMB.state = "exploding";
                            BOMB.explosionT = 0;

                            // si joueur sur une case touch√©e -> perdu
                            if (BOMB.affected.includes(playerNodeId)) {
                                killPlayer("Touch√© par la bombe !");
                            }
                        }
                    }
                    return;
                }

                // explosion anim
                if (BOMB.state === "exploding") {
                    BOMB.explosionT += dt;
                    if (BOMB.explosionT >= EXPLOSION_DURATION) {
                        BOMB.state = "idle";
                    }
                }
            }

            function drawBombWarning() {
                if (BOMB.state !== "warning" || !BOMB.visible) return;

                // cercle rouge translucide
                ctx.save();
                ctx.fillStyle = "rgba(255, 0, 0, 0.18)";
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, BOMB.r, 0, Math.PI * 2);
                ctx.fill();

                // contour
                ctx.strokeStyle = "rgba(255, 0, 0, 0.45)";
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, BOMB.r, 0, Math.PI * 2);
                ctx.stroke();

                // ic√¥ne ! au centre (r√©utilise ton style)
                drawWarningAt(BOMB.x, BOMB.y);

                ctx.restore();
            }

            function drawBombExplosion() {
                if (BOMB.state !== "exploding") return;

                const t = Math.min(1, BOMB.explosionT / EXPLOSION_DURATION);

                // expansion + fade
                const R = BOMB.r * (0.6 + 0.6 * t);

                ctx.save();

                // flash central
                ctx.fillStyle = `rgba(255,120,0,${0.25 * (1 - t)})`;
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, R, 0, Math.PI * 2);
                ctx.fill();

                // ring
                ctx.strokeStyle = `rgba(255,60,0,${0.55 * (1 - t)})`;
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(BOMB.x, BOMB.y, R, 0, Math.PI * 2);
                ctx.stroke();

                // marque les cases touch√©es en rouge pendant l'explosion
                for (const id of BOMB.affected) {
                    const n = getNode(id);
                    if (!n) continue;
                    ctx.fillStyle = `rgba(255,0,0,${0.22 * (1 - t)})`;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 14, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // ====== Animation update ======
            let lastTime = performance.now();
            function update() {
                const now = performance.now();
                const dt = Math.min(0.033, (now - lastTime) / 1000);
                lastTime = now;

                if (gameOver || gameWon) return;
                // ===== BOMBE AUTO =====
                bombTimer -= dt;
                if (bombTimer <= 0) {
                    startBombAttack();
                    bombTimer = BOMB_INTERVAL;
                }

                // Timer attaque auto
                nextFireIn -= dt;
                if (nextFireIn <= 0) {
                    startRandomFireAttack();
                    // Prochaine attaque al√©atoire entre 1.8s et 3.5s
                    nextFireIn = 1.8 + Math.random() * 1.7;
                }

                // player move
                if (isMoving) {
                    playerTrail.push({ x: playerPos.x, y: playerPos.y, life: 1 });
                    if (playerTrail.length > TRAIL_MAX) playerTrail.shift();
                    const dx = playerTarget.x - playerPos.x;
                    const dy = playerTarget.y - playerPos.y;
                    const dist = Math.hypot(dx, dy);
                    const step = PLAYER_SPEED * dt;

                    if (dist <= step) {
                        playerPos.x = playerTarget.x;
                        playerPos.y = playerTarget.y;
                        isMoving = false;

                        collectEnergyIfOnNode(); //l'energi collecter
                    } else {
                        playerPos.x += (dx / dist) * step;
                        playerPos.y += (dy / dist) * step;
                    }
                }
                for (const p of playerTrail) p.life -= dt * 2.2;  // vitesse de disparition
                playerTrail = playerTrail.filter(p => p.life > 0);

                // fire attack
                updateFire(dt);
                updateBomb(dt);
                updateKaiju(dt);
                updateEnergyFX(dt);
            }


            function drawPlayerFancy(x, y) {
                ctx.save();

                // ========= TRAIL / CHALEUR (capsules) =========
                if (playerTrail.length >= 2) {
                    for (let i = 0; i < playerTrail.length - 1; i++) {
                        const a = playerTrail[i];
                        const b = playerTrail[i + 1];
                        const t = a.life; // 1 -> 0

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const ang = Math.atan2(dy, dx);
                        const dist = Math.hypot(dx, dy);

                        // capsule = un rectangle arrondi avec rotation
                        ctx.save();
                        ctx.translate(a.x, a.y);
                        ctx.rotate(ang);

                        const w = Math.max(22, dist);
                        const h = 26;

                        // glow
                        ctx.fillStyle = `rgba(180, 80, 255, ${0.38 * t})`;
                        roundRectFill(-w * 0.2, -h / 2, w, h, 999);

                        // coeur clair
                        ctx.fillStyle = `rgba(200, 160, 255, ${0.10 * t})`;
                        roundRectFill(-w * 0.1, -h * 0.35, w * 0.75, h * 0.7, 999);

                        ctx.restore();
                    }
                }

                // ========= HALO EXTERNE =========
                ctx.fillStyle = "rgba(160, 60, 255, 0.18)";
                ctx.beginPath();
                ctx.arc(x, y, 44, 0, Math.PI * 2);
                ctx.fill();

                // ========= BOULE =========
                ctx.fillStyle = "#a03cff";
                ctx.beginPath();
                ctx.arc(x, y, 22, 0, Math.PI * 2);
                ctx.fill();

                // ========= √âTOILE LUMINEUSE =========
                drawStar(x, y, 10, 22, 12, "rgba(40,0,255,0.95)");
                drawStar(x, y, 6, 16, 12, "rgba(255,255,255,0.35)");

                // petit reflet
                ctx.fillStyle = "rgba(255,255,255,0.55)";
                ctx.beginPath();
                ctx.arc(x - 6, y - 7, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // √©toile
            function drawStar(cx, cy, innerR, outerR, spikes, color) {
                ctx.save();
                ctx.fillStyle = color;
                ctx.beginPath();

                let rot = -Math.PI / 2;
                const step = Math.PI / spikes;

                ctx.moveTo(cx, cy - outerR);
                for (let i = 0; i < spikes; i++) {
                    ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
                    rot += step;
                    ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
                    rot += step;
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // rectangle arrondi simple
            function roundRectFill(x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
                ctx.fill();
            }
            let energyFX = []; // effets visuels de ramassage

            function spawnEnergyPop(x, y) {
                // anneau + particules
                energyFX.push({
                    x, y,
                    t: 0,
                    duration: 0.45,
                    sparks: Array.from({ length: 10 }, () => {
                        const a = Math.random() * Math.PI * 2;
                        const sp = 160 + Math.random() * 220;
                        return { vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, r: 2 + Math.random() * 2 };
                    })
                });
            }

            function updateEnergyFX(dt) {
                for (const fx of energyFX) fx.t += dt;
                energyFX = energyFX.filter(fx => fx.t < fx.duration);
            }

            function drawEnergyFX() {
                for (const fx of energyFX) {
                    const p = fx.t / fx.duration;       // 0 -> 1
                    const a = 1 - p;                    // fade out

                    // anneau pop
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";
                    ctx.strokeStyle = `rgba(0,255,160,${0.9 * a})`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, 18 + p * 55, 0, Math.PI * 2);
                    ctx.stroke();

                    // petit flash
                    ctx.fillStyle = `rgba(220,255,245,${0.20 * a})`;
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, 22 + p * 35, 0, Math.PI * 2);
                    ctx.fill();

                    // sparks
                    for (const s of fx.sparks) {
                        const sx = fx.x + s.vx * fx.t * 0.018;
                        const sy = fx.y + s.vy * fx.t * 0.018;
                        ctx.fillStyle = `rgba(0,255,160,${0.85 * a})`;
                        ctx.beginPath();
                        ctx.arc(sx, sy, s.r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.globalCompositeOperation = "source-over";

                    // +1 flottant
                    ctx.fillStyle = `rgba(190,255,225,${0.95 * a})`;
                    ctx.font = "bold 18px system-ui";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("+1", fx.x, fx.y - 30 - p * 22);

                    ctx.restore();
                }
            }
            // ====== Draw ======
            function draw() {
                resizeCanvasToDisplaySize();
                update();
                // NE PAS remplir en blanc : le CSS du canvas fait le fond
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const { ox, oy } = getCenterOffset();
                ctx.save();
                ctx.translate(ox, oy);

                // edges
                for (const [aId, bId] of edges) {
                    const a = getNode(aId);
                    const b = getNode(bId);
                    if (!a || !b) continue;

                    ctx.lineCap = "round";

                    ctx.strokeStyle = "rgba(0,0,0,0.55)";
                    ctx.lineWidth = EDGE_WIDTH + 4;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();

                    ctx.strokeStyle = "rgba(140,140,140,0.45)";
                    ctx.lineWidth = EDGE_WIDTH;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }

                // nodes
                for (const n of nodes) {
                    const isHovered = n.id === hoveredId;
                    const isSelected = n.id === selectedId;

                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = "rgba(90,90,90,0.85)";
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();

                    if (isHovered || isSelected) {
                        ctx.strokeStyle = isSelected ? "#00d1ff" : "#ffd166";
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, NODE_RADIUS + 8, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = "rgba(0,0,0,0.55)";
                    ctx.font = "bold 16px system-ui";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(String(n.id), n.x, n.y);
                }

                function drawEnergyModule() {
                    if (ENERGY.nodeId === null) return;
                    const n = getNode(ENERGY.nodeId);
                    if (!n) return;

                    // halo
                    ctx.fillStyle = "rgba(0,255,160,0.25)";
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 18, 0, Math.PI * 2);
                    ctx.fill();

                    // module (petit losange)
                    ctx.fillStyle = "#00ff9a";
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y - 16);
                    ctx.lineTo(n.x + 16, n.y);
                    ctx.lineTo(n.x, n.y + 16);
                    ctx.lineTo(n.x - 16, n.y);
                    ctx.closePath();
                    ctx.fill();

                    // petit reflet
                    ctx.fillStyle = "rgba(255,255,255,0.6)";
                    ctx.beginPath();
                    ctx.arc(n.x - 6, n.y - 6, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                drawBorderWarning(); // warning AU-DESSUS du terrain
                drawFireball();      // boule AU-DESSUS
                drawBombWarning();
                drawBombExplosion();
                drawKaiju();
                drawEnergyModule();
                drawEnergyFX();


                drawPlayerFancy(playerPos.x, playerPos.y);

                // texte √©dition
                if (editMode) {
                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.font = "14px system-ui";
                    ctx.textAlign = "left";
                    ctx.fillText("Mode √©dition ON : drag pour bouger une case", 14, 24);
                    ctx.fillText("Touche F : tir horizontal | Shift+F : tir vertical", 14, 44);
                } else {
                    ctx.fillStyle = "rgba(0,0,0,0.55)";
                    ctx.font = "14px system-ui";
                    ctx.textAlign = "left";
                    ctx.fillText("Touche F : tir horizontal | Shift+F : tir vertical", 14, 24);
                }

                ctx.restore();
                //jeu terminer
                if (gameOver || gameWon) {
                    ctx.fillStyle = "rgba(0,0,0,0.45)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = "#fff";
                    ctx.font = "bold 52px system-ui";
                    ctx.textAlign = "center";

                    ctx.fillText(
                        gameWon ? "TU AS GAGN√â !" : "T'AS PERDU",
                        canvas.width / 2,
                        canvas.height / 2 - 15
                    );

                    ctx.font = "18px system-ui";
                    ctx.fillStyle = "rgba(255,255,255,0.9)";
                    ctx.fillText(endMsg, canvas.width / 2, canvas.height / 2 + 22);

                    ctx.fillText(
                        "Appuie sur R pour recommencer",
                        canvas.width / 2,
                        canvas.height / 2 + 55
                    );
                }
                requestAnimationFrame(draw);
            }
            //feu aleratoire
            function startRandomFireAttack() {
                if (FIRE.state !== "idle" || gameOver) return;

                const axis = Math.random() < 0.5 ? "h" : "v";
                FIRE.axis = axis;

                const b = getPlayBounds();

                if (axis === "h") {
                    FIRE.lineY = b.top + Math.random() * (b.bottom - b.top);
                    FIRE.lineX = playerPos.x;
                } else {
                    FIRE.lineX = b.left + Math.random() * (b.right - b.left);
                    FIRE.lineY = playerPos.y;
                }

                FIRE.state = "warning";
                FIRE.t = 0;
                FIRE.blinkStep = 0;
                FIRE.visible = true;
                FIRE.projectile = null;
            }

            // ====== Events ======
            canvas.addEventListener("mousemove", (e) => {
                const { x, y } = getMousePos(e);
                hoveredId = hitNode(x, y);
                if (uiHovered) uiHovered.textContent = hoveredId ?? "-";
                //uiHovered.textContent = hoveredId ?? "-";

                if (editMode && draggingId !== null) {
                    const n = getNode(draggingId);
                    if (n) {
                        n.x = x - dragOffset.x;
                        n.y = y - dragOffset.y;

                        // si on d√©place la case du joueur (et pas en mouvement)
                        if (n.id === playerNodeId && !isMoving) {
                            playerPos.x = n.x; playerPos.y = n.y;
                            playerTarget.x = n.x; playerTarget.y = n.y;
                        }
                    }
                }
            });

            canvas.addEventListener("mousedown", (e) => {
                const { x, y } = getMousePos(e);
                const id = hitNode(x, y);

                if (editMode) {
                    if (id !== null) {
                        draggingId = id;
                        const n = getNode(id);
                        dragOffset.x = x - n.x;
                        dragOffset.y = y - n.y;
                    }
                    return;
                }

                if (id !== null) {
                    selectedId = id;
                    if (uiSelected) uiSelected.textContent = String(selectedId);
                    movePlayerTo(id);
                }
            });

            window.addEventListener("mouseup", () => {
                draggingId = null;
            });

            btnToggleEdit.addEventListener("click", () => {
                setEditMode(!editMode);
            });

            btnReset.addEventListener("click", () => {
                resetPositions();
            });

            window.addEventListener("keydown", (e) => {
                if (e.code === "KeyR") {
                    gameOver = false;
                    gameOverMsg = "";
                    playerNodeId = 1;
                    initPlayer();
                    initKaijuSpawnSystem();
                    BOMB.state = "idle";
                    FIRE.state = "idle";
                }
            });

            // init
            setEditMode(false);
            initPlayer();
            initKaijuSpawnSystem();
            energyUI.textContent = "0";
            spawnEnergyModule();
            draw();
        })();





    </script>


</body>

</html>